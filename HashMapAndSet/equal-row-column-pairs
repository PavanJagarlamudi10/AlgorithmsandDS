Given a 0-indexed n x n integer matrix grid, return the number of pairs (ri, cj) such that row ri and column cj are equal.

A row and column pair is considered equal if they contain the same elements in the same order (i.e., an equal array).

// T - O(n*2) , S - O(n*2)
var equalPairs = function (grid) {
    const rowsFreq = {};
    const n = grid.length;

    if (n === 1 || n === 0) {
        return n;
    }
    //row map freq builder
    for (let row of grid) {
        rowsFreq[row] = (rowsFreq[row] ?? 0) + 1;
    }

    let count = 0;
    for (let c = 0; c < n; c++) {
        const col = [];
        for (let r = 0; r < n; r++) {
            col.push(grid[r][c]);
        }
        const colStr = col.join(',');
        const rowFreq = rowsFreq[colStr];
        if(rowFreq > 0) {
            count += rowFreq;
        }
    }
    return count;
};

// Hashbased keys to optimize S - O(n)
var equalPairs = function(grid) {
    const n = grid.length;
    if (n === 0) return 0;
    
    const base = 101;           // prime base for hashing
    const mod = 1_000_000_007;  // large prime to reduce collisions
    
    // Step 1: Compute hash of each row and store frequency
    const rowHashes = new Map();
    for (let r = 0; r < n; r++) {
        let hash = 0;
        for (let c = 0; c < n; c++) {
            hash = (hash * base + grid[r][c]) % mod;
        }
        rowHashes.set(hash, (rowHashes.get(hash) ?? 0) + 1);
    }

    // Step 2: Compute hash of each column and compare with row hashes
    let count = 0;
    for (let c = 0; c < n; c++) {
        let hash = 0;
        for (let r = 0; r < n; r++) {
            hash = (hash * base + grid[r][c]) % mod;
        }
        // Increment count if a matching row hash exists
        count += rowHashes.get(hash) ?? 0;
    }

    return count;
};
